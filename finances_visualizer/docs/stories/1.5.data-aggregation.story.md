# Story 1.5: Data Aggregation and Summary

## Story Metadata

```yaml
epic: 1
story: 5
title: Data Aggregation and Summary
status: Draft
created: 2026-02-03
estimated_days: 1.5
complexity: Medium

clickup:
  task_id: ""
  epic_task_id: ""
  list: "Backlog"
  url: ""
  last_sync: ""
```

---

## User Story

**As a** user,
**I want** to see summary statistics (total income, expense, balance, count),
**so that** I can quickly understand my financial picture.

---

## Acceptance Criteria

1. Aggregation function accepts `Transaction[]` â†’ returns `Summary` object
2. Summary includes: `totalIncome`, `totalExpense`, `netBalance`, `transactionCount`
3. Filters by date range (start, end dates)
4. Groups by category: `CategorySummary[]` (name, amount, percentage)
5. Groups by month: `MonthlySummary[]` for trends
6. Handles edge cases: empty array, single transaction, future dates
7. All calculations use proper float arithmetic (toFixed(2) for display)
8. Type-safe with TypeScript

---

## Requirements Mapping

| AC | Functional Requirement | Notes |
|----|----------------------|-------|
| AC1 | FR12 | Summary calculation |
| AC2 | FR12 | Summary fields |
| AC3 | FR7 | Date filtering |
| AC4 | FR12 | Category grouping |
| AC5 | FR12 | Monthly grouping |
| AC6 | FR11 | Edge cases |
| AC7 | NFR1 | Precision |
| AC8 | - | TypeScript |

---

## ðŸ¤– CodeRabbit Integration

> **CodeRabbit Integration**: Enabled

### Story Type Analysis

- **Primary Type**: API (data transformation)
- **Secondary Type(s)**: Frontend (displays results)
- **Complexity**: Low (aggregation logic)

### Specialized Agent Assignment

- **Primary Agents**: @dev (aggregation functions)
- **Supporting Agents**: None

### Quality Gate Tasks

- [ ] Pre-Commit (@dev): Run `coderabbit --prompt-only -t uncommitted` before marking story complete
- [ ] Pre-PR (@github-devops): Run `coderabbit --prompt-only --base main` before creating pull request

### CodeRabbit Focus Areas

**Primary Focus:**
- Float arithmetic uses proper precision (no floating point errors)
- Date range filtering handles edge cases
- Empty array handling doesn't crash
- TypeScript types are accurate

**Secondary Focus:**
- Performance for large datasets
- Category percentage calculations sum to 100%

### Self-Healing Configuration

```
Expected Self-Healing:
  - Primary Agent: @dev (light mode)
  - Max Iterations: 2
  - Timeout: 15 minutes
  - Severity Filter: CRITICAL only
```

---

## Dev Notes

### Data Structures [Source: PRD Epic 1]

```typescript
interface Summary {
  totalIncome: number;
  totalExpense: number;
  netBalance: number;
  transactionCount: number;
  dateRange: {
    start: Date;
    end: Date;
  };
}

interface CategorySummary {
  category: string;
  amount: number;
  percentage: number;  // of total expenses
  transactionCount: number;
}

interface MonthlySummary {
  month: string;       // "2024-01" format
  income: number;
  expense: number;
  balance: number;
  transactionCount: number;
}
```

### Implementation Location

Location: `src/lib/aggregation.ts`

**Functions:**
- `calculateSummary(transactions: Transaction[]): Summary`
- `filterByDateRange(transactions: Transaction[], start: Date, end: Date): Transaction[]`
- `groupByCategory(transactions: Transaction[]): CategorySummary[]`
- `groupByMonth(transactions: Transaction[]): MonthlySummary[]`

### Float Arithmetic Precision [AC: 7]

**Problem:** JavaScript floating point errors

```javascript
0.1 + 0.2 = 0.30000000000000004  // âŒ
```

**Solution:**
- Use `toFixed(2)` for display only
- Keep calculations in floats
- Round only final results

```typescript
// Good: Calculate with floats, round for display
const total = expenses.reduce((sum, t) => sum + t.amount, 0);
const display = total.toFixed(2);  // "1234.56"
```

### Date Range Filtering [AC: 3]

```typescript
function filterByDateRange(
  transactions: Transaction[],
  start: Date,
  end: Date
): Transaction[] {
  return transactions.filter(t => {
    const date = new Date(t.date);
    return date >= start && date <= end;
  });
}
```

**Edge Cases:**
- Start > End â†’ Return empty array
- Start or End undefined â†’ Return all
- Same day â†’ Include transactions on that day

### Category Grouping [AC: 4]

```typescript
function groupByCategory(transactions: Transaction[]): CategorySummary[] {
  // Group expenses only (not income)
  const expenses = transactions.filter(t => t.type === 'expense');

  // Sum by category
  const categoryMap = new Map<string, number>();
  expenses.forEach(t => {
    const cat = t.category || 'Outros';
    categoryMap.set(cat, (categoryMap.get(cat) || 0) + t.amount);
  });

  // Calculate total for percentages
  const totalExpense = Array.from(categoryMap.values()).reduce((a, b) => a + b, 0);

  // Convert to array with percentages
  return Array.from(categoryMap.entries()).map(([cat, amount]) => ({
    category: cat,
    amount,
    percentage: (amount / totalExpense) * 100,
    transactionCount: expenses.filter(t => t.category === cat).length
  }))
  .sort((a, b) => b.amount - a.amount);  // Sort by amount descending
}
```

### Monthly Grouping [AC: 5]

```typescript
function groupByMonth(transactions: Transaction[]): MonthlySummary[] {
  // Create map by month key
  const monthMap = new Map<string, {
    income: number;
    expense: number;
    count: number;
  }>();

  transactions.forEach(t => {
    const month = formatMonth(t.date);  // "2024-01"
    const current = monthMap.get(month) || { income: 0, expense: 0, count: 0 };

    if (t.type === 'income') {
      current.income += t.amount;
    } else {
      current.expense += t.amount;
    }
    current.count++;

    monthMap.set(month, current);
  });

  // Convert to sorted array
  return Array.from(monthMap.entries())
    .map(([month, data]) => ({
      month,
      income: data.income,
      expense: data.expense,
      balance: data.income - data.expense,
      transactionCount: data.count
    }))
    .sort((a, b) => a.month.localeCompare(b.month));
}

function formatMonth(date: Date): string {
  const y = date.getFullYear();
  const m = String(date.getMonth() + 1).padStart(2, '0');
  return `${y}-${m}`;
}
```

### Edge Case Handling [AC: 6]

```typescript
// Empty array
calculateSummary([]) â†’ {
  totalIncome: 0,
  totalExpense: 0,
  netBalance: 0,
  transactionCount: 0,
  dateRange: { start: null, end: null }
}

// Single transaction
calculateSummary([oneTransaction]) â†’ Works correctly

// Future dates
// Include in summary (user may have pending transactions)
```

### Performance Considerations

- Single pass through transactions for each aggregation
- Use Map for O(1) lookups
- Sort only at end (not during grouping)
- Test with 5,000 transactions

---

## Tasks / Subtasks

### Task 1: Define Type Interfaces (AC: 1, 8)

- Create `src/types/aggregation.ts`
- Define `Summary` interface
- Define `CategorySummary` interface
- Define `MonthlySummary` interface

### Task 2: Implement Summary Calculation (AC: 1, 2, 6, 7)

- Create `calculateSummary()` function
- Sum income transactions
- Sum expense transactions
- Calculate net balance
- Count transactions
- Handle empty array

### Task 3: Implement Date Filtering (AC: 3)

- Create `filterByDateRange()` function
- Filter by start date
- Filter by end date
- Handle edge cases (invalid dates, nulls)

### Task 4: Implement Category Grouping (AC: 4)

- Create `groupByCategory()` function
- Group expenses by category
- Calculate percentages
- Sort by amount descending
- Include transaction count

### Task 5: Implement Monthly Grouping (AC: 5)

- Create `groupByMonth()` function
- Group by YYYY-MM format
- Calculate income/expense/balance per month
- Sort chronologically

### Task 6: Add Utility Functions (AC: 7)

- Create `formatCurrency()` for display
- Create `formatPercentage()` for display
- Use `toFixed(2)` for precision

### Task 7: Create Tests (Coverage)

- Test summary calculation
- Test date filtering
- Test category grouping
- Test monthly grouping
- Test edge cases (empty, single, future dates)
- Test float precision

### Task 8: Performance Testing

- Test with 100 transactions
- Test with 1,000 transactions
- Test with 5,000 transactions
- Verify all operations < 1 second

---

## Testing Strategy

### Unit Tests (Vitest)

- Summary calculations with sample data
- Date range filtering
- Category grouping (verify percentages sum to 100)
- Monthly grouping
- Edge cases: empty array, single transaction

### Integration Tests

- Full aggregation pipeline: CSV â†’ categorized â†’ aggregated
- Verify summary values match expected

### Manual Testing

1. Upload real CSV
2. Verify summary numbers are correct
3. Check category percentages sum to 100%
4. Verify monthly data is accurate

---

## Definition of Done

- [x] All acceptance criteria met
- [x] Summary object contains all required fields
- [x] Date filtering working
- [x] Category grouping with percentages
- [x] Monthly grouping working
- [x] Edge cases handled
- [x] Float precision correct
- [x] TypeScript types defined
- [x] Tests passing
- [x] CodeRabbit review passed

---

*Story created by AIOS Framework*
*Scrum Master: @sm (River)*
*Date: 2026-02-03*
